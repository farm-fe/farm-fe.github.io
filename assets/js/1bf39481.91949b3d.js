"use strict";(self.webpackChunkfarm_docs=self.webpackChunkfarm_docs||[]).push([[9009],{2397:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>r});var c=i(6070),t=i(5658);const s={},d="Incremental Building",a={id:"advanced/persistent-cache",title:"Incremental Building",description:"Farm supports incremental build by persistent cache since v0.14.0",source:"@site/docs/advanced/persistent-cache.md",sourceDirName:"advanced",slug:"/advanced/persistent-cache",permalink:"/docs/advanced/persistent-cache",draft:!1,unlisted:!1,editUrl:"https://github.com/farm-fe/farm-fe.github.io/tree/main/docs/advanced/persistent-cache.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Syntax Downgrade and Polyfill",permalink:"/docs/advanced/polyfill"},next:{title:"Migrate From Vite",permalink:"/docs/migration/from-vite"}},l={},r=[{value:"Using Cache",id:"using-cache",level:2},{value:"Cache Validation",id:"cache-validation",level:2},{value:"Build Dependencies",id:"build-dependencies",level:2},{value:"Module Cache Key Strategy",id:"module-cache-key-strategy",level:2},{value:"Caveats For Plugins",id:"caveats-for-plugins",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.h1,{id:"incremental-building",children:"Incremental Building"}),"\n",(0,c.jsx)(n.admonition,{type:"tip",children:(0,c.jsxs)(n.p,{children:["Farm supports incremental build by persistent cache since ",(0,c.jsx)(n.code,{children:"v0.14.0"})]})}),"\n",(0,c.jsxs)(n.p,{children:["Since ",(0,c.jsx)(n.code,{children:"v0.14.0"}),", Farm supports cache the compiled result to disk, which can greatly speed up the compilation for hot start/hot build. When ",(0,c.jsx)(n.code,{children:"persistentCache"})," is enabled, the compilation time can reduce ",(0,c.jsxs)(n.strong,{children:["up to ",(0,c.jsx)(n.code,{children:"80%"})]}),"."]}),"\n",(0,c.jsxs)(n.p,{children:["Performance compare between cold start(without cache) and hot start(with cache) using ",(0,c.jsx)(n.a,{href:"https://github.com/farm-fe/farm/tree/main/examples/arco-pro",children:"examples/argo-pro"}),":"]}),"\n",(0,c.jsxs)(n.table,{children:[(0,c.jsx)(n.thead,{children:(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.th,{}),(0,c.jsx)(n.th,{children:"Cold(without cache)"}),(0,c.jsx)(n.th,{children:"Hot(with cache)"}),(0,c.jsx)(n.th,{children:"diff"})]})}),(0,c.jsxs)(n.tbody,{children:[(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"start"}),(0,c.jsx)(n.td,{children:"1519ms"}),(0,c.jsx)(n.td,{children:"371ms"}),(0,c.jsx)(n.td,{children:"reduced 75%"})]}),(0,c.jsxs)(n.tr,{children:[(0,c.jsx)(n.td,{children:"build"}),(0,c.jsx)(n.td,{children:"3582ms"}),(0,c.jsx)(n.td,{children:"562ms"}),(0,c.jsx)(n.td,{children:"reduced 84%"})]})]})]}),"\n",(0,c.jsx)(n.h2,{id:"using-cache",children:"Using Cache"}),"\n",(0,c.jsxs)(n.p,{children:["Using ",(0,c.jsx)(n.a,{href:"/docs/config/compilation-options#persistentcache",children:(0,c.jsx)(n.code,{children:"compilation.persistentCache"})})," to ",(0,c.jsx)(n.code,{children:"enable/disable"})," Cache:"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'import { defineConfig } from "@farmfe/core";\n\nexport default defineConfig({\n  compilation: {\n    persistentCache: true,\n  },\n});\n'})}),"\n",(0,c.jsxs)(n.admonition,{type:"note",children:[(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"persistentCache: true"})," is equal to:"]}),(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-js",children:'({\n  persistentCache: {\n    // Directory that cache is stored\n    cacheDir: "node_modules/.farm/cache",\n    // namespace of the cache\n    namespace: "farm-cache",\n    buildDependencies: [\n      "farm.config.ts",\n      "@farmfe/core",\n      "@farmfe/plugin-react",\n      // ... all other dependencies\n    ],\n    moduleCacheKeyStrategy: {\n      timestamp: true,\n      hash: true,\n    },\n  },\n});\n'})})]}),"\n",(0,c.jsxs)(n.p,{children:["Configuring ",(0,c.jsx)(n.code,{children:"persistentCache"})," to ",(0,c.jsx)(n.code,{children:"false"})," to disable cache."]}),"\n",(0,c.jsx)(n.h2,{id:"cache-validation",children:"Cache Validation"}),"\n",(0,c.jsx)(n.p,{children:"Cache will be validated when trying to reuse it by following conditions, if any of following conditions changed, all cache will be invalidated:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Env Object"}),": configured by ",(0,c.jsx)(n.code,{children:"persistentCache.envs"}),", default to ",(0,c.jsx)(n.code,{children:"Farm Env Mode"}),"(",(0,c.jsx)(n.code,{children:"process.env.NODE_ENV"}),", ",(0,c.jsx)(n.code,{children:"process.env.DEV"}),", ",(0,c.jsx)(n.code,{children:"process.env.PROD"}),"), see ",(0,c.jsx)(n.strong,{children:(0,c.jsx)(n.a,{href:"/docs/features/env",children:(0,c.jsx)(n.code,{children:"Environment Variables and Modes"})})}),"."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"lockfile"}),": If your lockfile changed, means there are dependencies changes, the cache will be invalidated."]}),"\n"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Build Dependencies"}),": configured by ",(0,c.jsx)(n.code,{children:"persistentCache.buildDependencies"}),", if any of the buildDependencies changed, all cache will be invalidated."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Cache Namespace"}),": configured by ",(0,c.jsx)(n.code,{children:"persistentCache.namespace"}),", cache under different namespaces won't be reused. If you want to invalidate all cache, you can configure a different namespace."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.strong,{children:"Internal Cache Version"}),": Farm maintains a cache version internally, if Farm itself changed, for example, render optimization that affects the output between versions of Farm, Farm will bump the cache version and all cache will be invalidated."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["If your cache does not work, check out above conditions to figure out the reason. If the cache is broken, you can also delete ",(0,c.jsx)(n.code,{children:"node_modules/.farm/cache"})," to remove cache manually."]}),"\n",(0,c.jsx)(n.h2,{id:"build-dependencies",children:"Build Dependencies"}),"\n",(0,c.jsx)(n.p,{children:"Build dependencies is dependencies that can affect the compilation process or compiled output, for examples, plugins or config files. If any of these dependencies changed, all cache will be invalidated."}),"\n",(0,c.jsx)(n.p,{children:"Build dependencies can be a file path for a package name, for example:"}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",children:'import { defineConfig } from "@farmfe/core";\nimport path from "node:path";\n\nexport default defineConfig({\n  persistentCache: {\n    buildDependencies: [\n      // a file path\n      path.resolve(process.cwd(), "./plugins/my-plugin.js"),\n      // a package name, note that this package must expose package.json\n      "farm-plugin-custom-xxx",\n    ],\n  },\n});\n'})}),"\n",(0,c.jsx)(n.admonition,{type:"note",children:(0,c.jsxs)(n.p,{children:["By default, all config files and its dependencies are included. But if you want to add some additional files or dependencies to invalidate the cache, you can using ",(0,c.jsx)(n.code,{children:"buildDependencies"})," once these files changed, all cache will be invalidated."]})}),"\n",(0,c.jsx)(n.h2,{id:"module-cache-key-strategy",children:"Module Cache Key Strategy"}),"\n",(0,c.jsx)(n.p,{children:"Farm provides 2 strategies to control how to generate module cache key:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"timestamp"}),": whether check timestamp of the module, if the update timestamp does not change, the build of this module will be skipped, which has the best performance."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"hash"}),": whether check content hash after load and transform, if the content does not change, the left build of this module will be skipped."]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["By default ",(0,c.jsx)(n.code,{children:"timestamp"})," and ",(0,c.jsx)(n.code,{children:"hash"})," are both enabled."]}),"\n",(0,c.jsx)(n.h2,{id:"caveats-for-plugins",children:"Caveats For Plugins"}),"\n",(0,c.jsxs)(n.p,{children:["when ",(0,c.jsx)(n.code,{children:"timestamp"})," is enabled, all build stages hooks like ",(0,c.jsx)(n.code,{children:"load"})," and ",(0,c.jsx)(n.code,{children:"transform"})," won't be called. So if the plugin relies ",(0,c.jsx)(n.code,{children:"load"})," and ",(0,c.jsx)(n.code,{children:"transform"})," and it does not implement ",(0,c.jsx)(n.code,{children:"plugin_cache_loaded"})," and ",(0,c.jsx)(n.code,{children:"write_plugin_cache"})," hook, it may not work as expected. For example, if a plugin collect information in ",(0,c.jsx)(n.code,{children:"load"})," and ",(0,c.jsx)(n.code,{children:"transform"}),", all emit them at ",(0,c.jsx)(n.code,{children:"finish"})," hook, it should implement ",(0,c.jsx)(n.code,{children:"plugin_cache_loaded"})," and ",(0,c.jsx)(n.code,{children:"write_plugin_cache"})," hook to load and write cache, otherwise it will not work as expected."]}),"\n",(0,c.jsxs)(n.p,{children:["Farm will set ",(0,c.jsx)(n.code,{children:"timestamp"})," to ",(0,c.jsx)(n.code,{children:"false"})," when ",(0,c.jsx)(n.code,{children:"output.targetEnv"})," is ",(0,c.jsx)(n.code,{children:"node"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}},5658:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>a});var c=i(758);const t={},s=c.createContext(t);function d(e){const n=c.useContext(s);return c.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),c.createElement(s.Provider,{value:n},e.children)}}}]);
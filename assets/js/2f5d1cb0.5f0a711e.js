"use strict";(self.webpackChunkfarm_docs=self.webpackChunkfarm_docs||[]).push([[8966],{4773:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>a,metadata:()=>u,toc:()=>p});var s=r(6070),i=r(385),l=r(1576),o=r(6116),t=r(2438);const a={},c="Writing Rust Plugins",u={id:"plugins/writing-plugins/rust-plugin",title:"Writing Rust Plugins",description:"Rust plugins are the recommended way to write your plugins cause Rust plugins are much faster and powerful than Js Plugins. A Rust plugin is a struct that implements farmfe_core:",source:"@site/docs/plugins/writing-plugins/rust-plugin.mdx",sourceDirName:"plugins/writing-plugins",slug:"/plugins/writing-plugins/rust-plugin",permalink:"/docs/plugins/writing-plugins/rust-plugin",draft:!1,unlisted:!1,editUrl:"https://github.com/farm-fe/farm-fe.github.io/tree/main/docs/plugins/writing-plugins/rust-plugin.mdx",tags:[],version:"current",frontMatter:{},sidebar:"pluginSidebar",previous:{title:"Overview",permalink:"/docs/plugins/writing-plugins/overview"},next:{title:"Writing JavaScript Plugins",permalink:"/docs/plugins/writing-plugins/js-plugin"}},d={},p=[{value:"Conventions",id:"conventions",level:2},{value:"Concepts",id:"concepts",level:2},{value:"Module Type",id:"module-type",level:3},{value:"Create Plugin",id:"create-plugin",level:2},{value:"Plugin Project Structure",id:"plugin-project-structure",level:2},{value:"Develop Plugin",id:"develop-plugin",level:2},{value:"Handle ModuleType",id:"handle-moduletype",level:3},{value:"Handle Plugin Options",id:"handle-plugin-options",level:3},{value:"Using farm_core In Plugin",id:"using-farm_core-in-plugin",level:3},{value:"Caveats",id:"caveats",level:3},{value:"Using SWC In Plugin",id:"using-swc-in-plugin",level:4},{value:"Choosing Rust toolchain",id:"choosing-rust-toolchain",level:4},{value:"Plugin Compatibility",id:"plugin-compatibility",level:3},{value:"Cross Build",id:"cross-build",level:2},{value:"Publish",id:"publish",level:2},{value:"Examples",id:"examples",level:2},{value:"Define Plugin",id:"define-plugin",level:3},{value:"Implement Plugin Trait",id:"implement-plugin-trait",level:3},{value:"Load <code>.scss</code> File",id:"load-scss-file",level:3},{value:"Transform <code>sass</code> File",id:"transform-sass-file",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"writing-rust-plugins",children:"Writing Rust Plugins"}),"\n",(0,s.jsxs)(n.p,{children:["Rust plugins are the recommended way to write your plugins cause Rust plugins are much ",(0,s.jsx)(n.strong,{children:"faster and powerful"})," than Js Plugins. A Rust plugin is a ",(0,s.jsx)(n.code,{children:"struct"})," that implements ",(0,s.jsx)(n.code,{children:"farmfe_core::plugin::Plugin"})," trait, example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#![deny(clippy::all)]\n\nuse farmfe_core::{config::Config, plugin::Plugin};\n\nuse farmfe_macro_plugin::farm_plugin;\n\n// define your rust plugins\n#[farm_plugin]\npub struct FarmPluginExample {}\n\nimpl FarmPluginExample {\n  // a Rust plugin must export a new method that accepts 2 arguments for initialization\u3002\n  fn new(config: &Config, options: String) -> Self {\n    Self {}\n  }\n}\n// Implement Plugin trait to define plugin hooks\nimpl Plugin for FarmPluginExample {\n  fn name(&self) -> &str {\n    "FarmPluginExample"\n  }\n\n  // more hooks here\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note for a Rust plugin struct:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The struct must be ",(0,s.jsx)(n.code,{children:"pub"})," and ",(0,s.jsx)(n.code,{children:"#[farm_plugin]"})," attribute is required."]}),"\n",(0,s.jsxs)(n.li,{children:["The struct must implement ",(0,s.jsx)(n.code,{children:"Plugin"})," trait, and the ",(0,s.jsx)(n.code,{children:"name"})," method must be implemented."]}),"\n",(0,s.jsxs)(n.li,{children:["The struct must export a ",(0,s.jsx)(n.code,{children:"new"})," method that accepts 2 arguments for initialization, the first argument is ",(0,s.jsx)(n.code,{children:"&Config"})," and the second argument is ",(0,s.jsx)(n.code,{children:"String"}),". The ",(0,s.jsx)(n.code,{children:"new"})," method is called when the plugin is loaded, and the ",(0,s.jsx)(n.code,{children:"Config"})," is the farm project config, and the ",(0,s.jsx)(n.code,{children:"String"})," is the plugin options."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["We also provide a Rust plugin example repository: ",(0,s.jsx)(n.a,{href:"https://github.com/farm-fe/rust-plugin-example",children:"farm-rust-plugin-example"}),"."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["This document only covers how to create, develop and publish a rust plugin, for more detail about the plugin hooks, see ",(0,s.jsx)(n.a,{href:"/docs/api/rust-plugin-api",children:"Plugin Hooks"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"conventions",children:"Conventions"}),"\n",(0,s.jsx)(n.p,{children:"For farm specific Rust plugins:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The Farm plugin should have a name with a ",(0,s.jsx)(n.code,{children:"farm-plugin-"})," prefix and clear semantics."]}),"\n",(0,s.jsxs)(n.li,{children:["Include the ",(0,s.jsx)(n.code,{children:"farm-plugin-"})," keyword in package.json."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If your plugin is only applicable to a specific framework, its name should follow the following prefix format:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"farm-plugin-vue-"}),": Prefix as a Vue plugin"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"farm-plugin-react-"}),": Prefix as a React plugin"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"farm-plugin-svelte-"}),": Prefix as a svelte plugin"]}),"\n",(0,s.jsx)(n.li,{children:"..."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsx)(n.p,{children:"Before you start to write your rust plugin, you should know the following concepts:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"module_type"}),": The type of the module, it can be ",(0,s.jsx)(n.code,{children:"js"}),", ",(0,s.jsx)(n.code,{children:"ts"}),", ",(0,s.jsx)(n.code,{children:"css"}),", ",(0,s.jsx)(n.code,{children:"sass"}),", ",(0,s.jsx)(n.code,{children:"json"}),", etc. Farm supports ",(0,s.jsx)(n.code,{children:"js/ts/jsx/tsx"}),", ",(0,s.jsx)(n.code,{children:"css"}),", ",(0,s.jsx)(n.code,{children:"html"}),", ",(0,s.jsx)(n.code,{children:"json"}),", ",(0,s.jsx)(n.code,{children:"static assets(png, svg, etc)"})," natively. ",(0,s.jsx)(n.code,{children:"module_type"})," is returned by ",(0,s.jsx)(n.code,{children:"load"})," hook. You can extend natively supported module type by Rust plugins the same as Farm internal plugins."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"resolved_path and module_id"}),": ",(0,s.jsx)(n.code,{children:"resolved_path"})," is the absolute path of the module, and ",(0,s.jsx)(n.code,{children:"module_id"})," is the unique id of the module, it's usually ",(0,s.jsx)(n.code,{children:"relative path of the module from the project root"})," + ",(0,s.jsx)(n.code,{children:"query"}),". For example, we import a module as ",(0,s.jsx)(n.code,{children:"import './a?query'"}),", the resolved_path is ",(0,s.jsx)(n.code,{children:"/project/src/a.ts"})," and the module_id is ",(0,s.jsx)(n.code,{children:"src/a.ts?query"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"context"}),": All the hooks in the plugin accept a ",(0,s.jsx)(n.code,{children:"context"})," argument, it's the compilation context of the farm project, you can use it to get the ModuleGraph, Module, Resources, etc."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource and Resource Pot"}),": ",(0,s.jsx)(n.code,{children:"Resource"})," is the final output bundle file, and ",(0,s.jsx)(n.code,{children:"Resource Pot"})," is the abstract representation of the resource, similar to ",(0,s.jsx)(n.code,{children:"Chunk"})," of other bundlers. Inside Farm, first we will generate ",(0,s.jsx)(n.code,{children:"Resource Pots"})," from ",(0,s.jsx)(n.code,{children:"ModuleGraph"}),", render ",(0,s.jsx)(n.code,{children:"Resource Pots"})," and finally generate ",(0,s.jsx)(n.code,{children:"Resources"})," from ",(0,s.jsx)(n.code,{children:"Resource Pots"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"module-type",children:"Module Type"}),"\n",(0,s.jsxs)(n.p,{children:["In Farm, every thing is ",(0,s.jsx)(n.code,{children:"First Class Citizens"}),", so Farm designs ",(0,s.jsx)(n.code,{children:"module_type"})," to identify the type of a module and handle different kinds of ModuleTypes in different plugins."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"module_type"})," returned by ",(0,s.jsx)(n.code,{children:"load"})," hook, and can be transformed by ",(0,s.jsx)(n.code,{children:"transform"})," hook. Farm supports ",(0,s.jsx)(n.code,{children:"js/ts/jsx/tsx"}),", ",(0,s.jsx)(n.code,{children:"css"}),", ",(0,s.jsx)(n.code,{children:"html"}),", ",(0,s.jsx)(n.code,{children:"json"}),", ",(0,s.jsx)(n.code,{children:"static assets(png, svg, etc)"})," natively. For these module types, you can return them directly in ",(0,s.jsx)(n.code,{children:"load"})," or ",(0,s.jsx)(n.code,{children:"transform"})," hook directly. But if you want to handle custom module types, you may need to implement ohter hooks like ",(0,s.jsx)(n.code,{children:"parse"}),", ",(0,s.jsx)(n.code,{children:"render_resource_pot_modules"}),", ",(0,s.jsx)(n.code,{children:"generate resources"}),", etc to control how to parse, render and generate resources for the custom module types."]}),"\n",(0,s.jsx)(n.h2,{id:"create-plugin",children:"Create Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Farm provides official templates to help your create your rust plugins quickly:"}),"\n",(0,s.jsx)(s.Fragment,{children:(0,s.jsxs)(o.A,{children:[(0,s.jsx)(t.A,{value:"pnpm",label:"pnpm",children:(0,s.jsx)(l.A,{children:"pnpm create farm-plugin"})}),(0,s.jsx)(t.A,{value:"npm",label:"npm",children:(0,s.jsx)(l.A,{children:"npm create farm-plugin@latest"})}),(0,s.jsx)(t.A,{value:"yarn",label:"yarn",children:(0,s.jsx)(l.A,{children:"yarn create farm-plugin"})})]})}),"\n",(0,s.jsx)(n.p,{children:"then follow the prompts to create your plugin."}),"\n",(0,s.jsx)(n.p,{children:"or you can create a plugin derectly by running the following command:"}),"\n",(0,s.jsxs)(o.A,{children:[(0,s.jsx)(t.A,{value:"pnpm",label:"pnpm",children:(0,s.jsx)(l.A,{children:"pnpm create farm-plugin my-farm-plugin --type rust"})}),(0,s.jsx)(t.A,{value:"npm",label:"npm",children:(0,s.jsx)(l.A,{children:"npm create my-farm-plugin --type rust"})}),(0,s.jsx)(t.A,{value:"yarn",label:"yarn",children:(0,s.jsx)(l.A,{children:"yarn create my-farm-plugin --type rust"})})]}),"\n",(0,s.jsxs)(n.p,{children:["Above command will create new rust plugin with name ",(0,s.jsx)(n.code,{children:"my-farm-plugin"})," in the current directory. ",(0,s.jsx)(n.code,{children:"--type"})," can be ",(0,s.jsx)(n.code,{children:"rust"})," or ",(0,s.jsx)(n.code,{children:"js"})]}),"\n",(0,s.jsx)(n.h2,{id:"plugin-project-structure",children:"Plugin Project Structure"}),"\n",(0,s.jsx)(n.p,{children:"The plugin project structure is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"my-farm-plugin\n\u251c\u2500\u2500 .github\n\u2502   \u2514\u2500\u2500 workflows\n|       \u251c\u2500\u2500 release.yml\n|       \u251c\u2500\u2500 build.yml\n\u2502       \u2514\u2500\u2500 ci.yml\n\u251c\u2500\u2500 Cargo.toml\n|\u2500\u2500 .gitignore\n\u251c\u2500\u2500 npm\n\u2502   \u251c\u2500\u2500 darwin-x64\n\u2502   \u251c\u2500\u2500 linux-x64-gnu\n|   \u251c\u2500\u2500 win32-x64-msvc\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 lib.rs\n\u2514\u2500\u2500 rust-toolchain.toml\n"})}),"\n",(0,s.jsx)(n.p,{children:"Notable files and directories:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"src/lib.rs"}),": The main file of the plugin, where you define your plugin."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Cargo.toml"}),": The manifest file for Rust."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"package.json"}),": The manifest file for npm."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"npm"}),": Where your platform specific binary packages placed. These packages should be published to npm registry before publish the plugin."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".github/workflows"}),": Used to cross build and publish your plugin in github actions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"rust-toolchain.toml"}),": The rust toolchain file, it should ",(0,s.jsx)(n.strong,{children:"not be modified manually"}),", it should always using ",(0,s.jsx)(n.strong,{children:"the same version as the farm core"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Farm provides a tool(",(0,s.jsx)(n.code,{children:"@farmfe/plugin-tools"}),") to help you build and publish your rust plugin, see ",(0,s.jsx)(n.code,{children:"package.json"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  // ...\n  "scripts": {\n    // build your plugin for current platform\n    "build": "farm-plugin-tools build --platform --cargo-name my_farm_plugin -p my_farm_plugin --release",\n    // publish all platform packages under npm directory to npm registry\n    "prepublishOnly": "farm-plugin-tools prepublish"\n  },\n  // ...\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["More detail about building and publishing your plugin, see ",(0,s.jsx)(n.a,{href:"#cross-build",children:"buidling"})," and ",(0,s.jsx)(n.a,{href:"#publish",children:"publishing"})," sections."]}),"\n",(0,s.jsx)(n.h2,{id:"develop-plugin",children:"Develop Plugin"}),"\n",(0,s.jsx)(n.p,{children:"To develop and test your plugin locally, you should build your plugin for your platform first, run:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"pnpm build\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Then you can use the built plugin in your farm project by adding the plugin to the ",(0,s.jsx)(n.code,{children:"plugins"})," field in ",(0,s.jsx)(n.code,{children:"farm.config.ts"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { defineConfig } from '@farmfe/core';\n\nexport default defineConfig({\n  plugins: [\n    'my-farm-plugin'\n  ]\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["and execute ",(0,s.jsx)(n.code,{children:"pnpm i"})," in your farm project, and run ",(0,s.jsx)(n.code,{children:"farm start"})," to start your farm project with your plugin."]}),"\n",(0,s.jsxs)(n.p,{children:["when you make changes to your plugin, you should rebuild your plugin and restart your farm project to see the changes. for example, add ",(0,s.jsx)(n.code,{children:"load"})," hook to your plugin:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'{8-18} title="src/lib.rs"',children:'// ... ignore other code\n\nimpl Plugin for FarmPluginExample {\n  fn name(&self) -> &str {\n    "FarmPluginExample"\n  }\n\n  fn load(\n    &self,\n    param: &farmfe_core::plugin::PluginLoadHookParam,\n    _context: &std::sync::Arc<farmfe_core::context::CompilationContext>,\n    _hook_context: &farmfe_core::plugin::PluginHookContext,\n  ) -> farmfe_core::error::Result<Option<farmfe_core::plugin::PluginLoadHookResult>> {\n    println!(\n      "load path: {:?}, id: {:?}",\n      param.resolved_path, param.module_id\n    );\n    Ok(None)\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Then rebuild your plugin with ",(0,s.jsx)(n.code,{children:"pnpm build"})," and restart your farm project with ",(0,s.jsx)(n.code,{children:"farm start"}),", you will see the ",(0,s.jsx)(n.code,{children:"load"})," hook is called when compiling your farm project."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["For more detail about the plugin hooks, see ",(0,s.jsx)(n.a,{href:"/docs/api/rust-plugin-api",children:"Plugin Hooks"}),"."]})}),"\n",(0,s.jsx)(n.h3,{id:"handle-moduletype",children:"Handle ModuleType"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"module_type"})," is returned by the ",(0,s.jsx)(n.code,{children:"load"})," hook or ",(0,s.jsx)(n.code,{children:"transform"})," hook. Your set any module type to the module in the ",(0,s.jsx)(n.code,{children:"load"})," hook, and the module will be processed by the corresponding plugin that supports the module type."]}),"\n",(0,s.jsxs)(n.p,{children:["For native supported module types, you can just return the module type in the ",(0,s.jsx)(n.code,{children:"load"})," hook:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'{8-18} title="src/lib.rs"',children:'// ... ignore other code\n\nimpl Plugin for FarmPluginExample {\n  fn name(&self) -> &str {\n    "FarmPluginExample"\n  }\n\n  fn load(\n    &self,\n    param: &farmfe_core::plugin::PluginLoadHookParam,\n    _context: &std::sync::Arc<farmfe_core::context::CompilationContext>,\n    _hook_context: &farmfe_core::plugin::PluginHookContext,\n  ) -> farmfe_core::error::Result<Option<farmfe_core::plugin::PluginLoadHookResult>> {\n    // handle virtual module\n    if param.module_id.starts_with("virtual:my-css:css") {\n      // return module type and content\n      Ok(Some(farmfe_core::plugin::PluginLoadHookResult {\n        module_type: "css".to_string(),\n        content: ".red { color: red; }".to_string(),\n        ..Default::default()\n      }))\n    } else {\n      Ok(None)\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For non-native supported module types, you should use ",(0,s.jsx)(n.code,{children:"transform"})," hook to transform the module type to a native supported module type, otherwise you need to implement ",(0,s.jsx)(n.code,{children:"parse"}),", ",(0,s.jsx)(n.code,{children:"renderResourcePot"})," hook to handle your custom module type:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'{8-18} title="src/lib.rs"',children:'// ... ignore other code\n\nimpl Plugin for FarmPluginExample {\n  fn name(&self) -> &str {\n    "FarmPluginExample"\n  }\n\n  fn transform(\n    &self,\n    param: &farmfe_core::plugin::PluginTransformHookParam,\n    _context: &std::sync::Arc<farmfe_core::context::CompilationContext>,\n    _hook_context: &farmfe_core::plugin::PluginHookContext,\n  ) -> farmfe_core::error::Result<Option<farmfe_core::plugin::PluginTransformHookResult>> {\n    // module type guard is required\n    if matches!(param.module_type, ModuleType::Custom("sass")) {\n      // compile sass and transform the module type from sass to css\n      Ok(Some(farmfe_core::plugin::PluginTransformHookResult {\n        module_type: "css".to_string(),\n        content: compileSass(param.content),\n        ..Default::default()\n      }))\n    } else {\n      Ok(None)\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Module type guard like ",(0,s.jsx)(n.code,{children:'matches!(param.module_type, ModuleType::Custom("sass"))'})," is required in the ",(0,s.jsx)(n.code,{children:"transform"})," hook, cause the ",(0,s.jsx)(n.code,{children:"transform"})," hook will be called for all module types, and you should only handle your custom module type in the ",(0,s.jsx)(n.code,{children:"transform"})," hook. So do the ",(0,s.jsx)(n.code,{children:"parse"})," and other hooks."]})}),"\n",(0,s.jsxs)(n.p,{children:["or implement ",(0,s.jsx)(n.code,{children:"parse"}),", ",(0,s.jsx)(n.code,{children:"render_resource_pot_modules"})," hook to handle your custom module type, see how native farm css plugin handle ",(0,s.jsx)(n.code,{children:"css"})," module type in ",(0,s.jsx)(n.a,{href:"https://github.com/farm-fe/farm/blob/main/crates/plugin_html/src/lib.rs#L159",children:"farm-plugin-css"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"handle-plugin-options",children:"Handle Plugin Options"}),"\n",(0,s.jsxs)(n.p,{children:["The rust plugin options can be configured in ",(0,s.jsx)(n.code,{children:"farm.config.ts"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { defineConfig } from '@farmfe/core';\n\nexport default defineConfig({\n  plugins: [\n    ['my-farm-plugin', {\n      // plugin options\n      myOption: 'myOption'\n    }]\n  ]\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The Option will be json serialized and passed to the ",(0,s.jsx)(n.code,{children:"new"})," method of your plugin, you can handle the options in the ",(0,s.jsx)(n.code,{children:"new"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/lib.rs"',children:"// ... ignore other code\n\n// define your rust plugin options\n#[derive(serde::Deserialize)]\npub struct Options {\n  pub my_option: Option<String>,\n}\n\nimpl FarmPluginExample {\n  fn new(config: &Config, options: String) -> Self {\n    // deserialize the options\n    let my_option: Options = serde_json::from_str(&options).unwrap();\n    // handle the options...\n    Self {}\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note that you should add dependencies ",(0,s.jsx)(n.code,{children:"serde"})," and ",(0,s.jsx)(n.code,{children:"serde_json"})," to your ",(0,s.jsx)(n.code,{children:"Cargo.toml"})," to support options deserialization:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\n# ... ignore other code\nserde = { version = "1.0", features = ["derive"] }\nserde_json = "1.0"\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Non json serializable options are not supported. Which means you can only use types like string, number, boolean, array, object, etc. ",(0,s.jsx)(n.code,{children:"function options"})," are not supported."]})}),"\n",(0,s.jsx)(n.h3,{id:"using-farm_core-in-plugin",children:"Using farm_core In Plugin"}),"\n",(0,s.jsxs)(n.p,{children:["Farm exposes all core structures and utilities in ",(0,s.jsx)(n.a,{href:"https://docs.rs/farmfe_core",children:(0,s.jsx)(n.code,{children:"farmfe_core"})})," crate. Refer to the ",(0,s.jsx)(n.a,{href:"https://docs.rs/farmfe_core",children:"farmfe_core"})," documentation for more detail."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["If you want to use swc structures like ",(0,s.jsx)(n.code,{children:"Module"}),", ",(0,s.jsx)(n.code,{children:"Program"}),", etc. in your plugin, you should use ",(0,s.jsx)(n.code,{children:"farmfe_core::swc_ast"})," that re-exposed by farm core. Cause the swc version used by farm core may be different from the swc version you used in your plugin, and the swc version used by farm core is guaranteed to be compatible with farm core."]})}),"\n",(0,s.jsx)(n.h3,{id:"caveats",children:"Caveats"}),"\n",(0,s.jsx)(n.h4,{id:"using-swc-in-plugin",children:"Using SWC In Plugin"}),"\n",(0,s.jsxs)(n.p,{children:["Note that your rust plugin should not use any SWC related packages like ",(0,s.jsx)(n.code,{children:"swc_common"}),", ",(0,s.jsx)(n.code,{children:"swc_transforms"}),", etc. Cause SWC stores the global state in the process, it may cause ",(0,s.jsx)(n.strong,{children:"dead lock"})," when you use SWC in your plugin."]}),"\n",(0,s.jsxs)(n.p,{children:["Farm recommended to write ",(0,s.jsx)(n.a,{href:"/docs/using-plugins#using-swc-plugins",children:"SWC Plugin"})," if you want to make changes to the AST of your farm project. For how to write SWC plugin, see ",(0,s.jsx)(n.a,{href:"https://swc.rs/docs/plugin/ecmascript/getting-started",children:"Write SWC Plugin"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"choosing-rust-toolchain",children:"Choosing Rust toolchain"}),"\n",(0,s.jsxs)(n.p,{children:["Cause Farm Rust Plugin is a dynamic linked library, you should always use the same version of the rust toolchain as the farm core. The rust toolchain is defined in ",(0,s.jsx)(n.code,{children:"rust-toolchain.toml"}),", it should ",(0,s.jsx)(n.strong,{children:"not be modified manually"}),".\nAnd should should always build your plugin from Rust, cause Farm Core does not support FFI and not promise ABI stability to provide best performance."]}),"\n",(0,s.jsx)(n.h3,{id:"plugin-compatibility",children:"Plugin Compatibility"}),"\n",(0,s.jsxs)(n.p,{children:["Farm core maintains a API version that exposes to the plugin. If you met a message like ",(0,s.jsx)(n.code,{children:"Incompatible Rust Plugin: Current core's version..."}),", it means your plugin is not compatible with the current farm core version. You should update your plugin to the latest version to fix the issue."]}),"\n",(0,s.jsx)(n.p,{children:"For plugin authors, you should rebuild and publish your plugin for the latest farm core version to make your plugin compatible with the latest farm core version."}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Farm promises API Compatibility for the same major version, for example, if your plugin is compatible with farm core 1.0.0, it should also be compatible with farm core 1.1.0, 1.2.0, etc. which means your plugin will always work for the same major version of farm."})}),"\n",(0,s.jsx)(n.h2,{id:"cross-build",children:"Cross Build"}),"\n",(0,s.jsxs)(n.p,{children:["A Farm Rust Plugin is a ",(0,s.jsx)(n.strong,{children:"platform specific dynamic linked library"}),", you should build your plugin for all platforms you want to support.\nFarm provided a example for how to build your plugin using github actions, see ",(0,s.jsx)(n.a,{href:"https://github.com/farm-fe/rust-plugin-example/blob/main/.github/workflows/build.yaml",children:".github/workflows/build.yml"})]}),"\n",(0,s.jsx)(n.p,{children:"By default, A farm rust plugin should be built for the following platforms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"linux-x64-gnu "})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"linux-x64-musl"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"darwin-x64"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"win32-x64-msvc"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"linux-arm64-musl"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"linux-arm64-gnu"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"darwin-arm64"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"win32-ia32-msvc"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"win32-arm64-msvc"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For a public plugin that published to npm registry, we recommend you to publish your plugin for all platforms above. For a private rust plugin, you can build your plugin for any platform you want to support."}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsx)(n.p,{children:"Cause a rust plugin is a pure dynamic linked library, if you have questions about how to build your plugin for a specific platform, just google how to build a dynamic linked library for that platform in Rust."})}),"\n",(0,s.jsx)(n.h2,{id:"publish",children:"Publish"}),"\n",(0,s.jsx)(n.p,{children:"Steps to publish your Rust plugin:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Cross build the Rust plugin to dynamic linked library, see ",(0,s.jsx)(n.a,{href:"#cross-build",children:"Cross Build"})," for detail."]}),"\n",(0,s.jsxs)(n.li,{children:["Copy the binary artifacts to npm dir, for example: Copy to ",(0,s.jsx)(n.code,{children:"npm/linux-x64-gnu/index.farm"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Publish platform specific packages under npm dir, you can use ",(0,s.jsx)(n.code,{children:"farm-plugin-tool prepublish"})," to publish packages under ",(0,s.jsx)(n.code,{children:"npm"})," dir."]}),"\n",(0,s.jsx)(n.li,{children:"Publish the package itself"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["see example ",(0,s.jsx)(n.a,{href:"https://github.com/farm-fe/rust-plugin-example/blob/main/.github/workflows/release.yml",children:"github actions publish workflow"})]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.p,{children:["We will use ",(0,s.jsx)(n.code,{children:"@farmfe/plugin-sass"})," as demostration to a real Rust plugin example. This plugin will support compiling ",(0,s.jsx)(n.code,{children:".scss"})," and ",(0,s.jsx)(n.code,{children:".sass"})," file in your farm project."]}),"\n",(0,s.jsx)(n.h3,{id:"define-plugin",children:"Define Plugin"}),"\n",(0,s.jsxs)(n.p,{children:["Exports a Rust struct named ",(0,s.jsx)(n.code,{children:"FarmPluginSass"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:'title="src/lib.rs"',children:'use farmfe_macro_plugin::farm_plugin;\n\n// 1. define a struct with #[farm_plugin] attribute\n#[farm_plugin]\npub struct FarmPluginSass {\n  sass_options: String,\n  regex: Regex,\n}\n\nimpl FarmPluginSass {\n  // 2. define a new method with 2 arguments\n  pub fn new(_config: &Config, options: String) -> Self {\n    Self {\n      sass_options: options,\n      regex: Regex::new(r#"\\.(sass|scss)$"#).unwrap(),\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The struct must be ",(0,s.jsx)(n.code,{children:"pub"})," and ",(0,s.jsx)(n.code,{children:"#[farm_plugin]"})," attribute is required."]}),"\n",(0,s.jsxs)(n.li,{children:["The struct must export a ",(0,s.jsx)(n.code,{children:"new"})," method that accepts 2 arguments for initialization, the first argument is ",(0,s.jsx)(n.code,{children:"&Config"})," and the second argument is ",(0,s.jsx)(n.code,{children:"String"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implement-plugin-trait",children:"Implement Plugin Trait"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Plugin"})," trait is used to define ",(0,s.jsx)(n.code,{children:"hooks"})," that can hook into Farm compiler."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"{21-30}",children:'use farmfe_core::plugin::Plugin;\nuse farmfe_macro_plugin::farm_plugin;\n\n// 1. define a struct with #[farm_plugin] attribute\n#[farm_plugin]\npub struct FarmPluginSass {\n  sass_options: String,\n  regex: Regex,\n}\n\nimpl FarmPluginSass {\n  // 2. define a new method with 2 arguments\n  pub fn new(_config: &Config, options: String) -> Self {\n    Self {\n      sass_options: options,\n      regex: Regex::new(r#"\\.(sass|scss)$"#).unwrap(),\n    }\n  }\n}\n// Implement Plugin Trait\nimpl Plugin for FarmPluginSass {\n  fn name(&self) -> &str {\n    "FarmPluginSass"\n  }\n\n  // this plugin should be executed before internal plugins\n  fn priority(&self) -> i32 {\n    101\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"load-scss-file",children:["Load ",(0,s.jsx)(n.code,{children:".scss"})," File"]}),"\n",(0,s.jsxs)(n.p,{children:["Implement ",(0,s.jsx)(n.code,{children:"load"})," hook to support load ",(0,s.jsx)(n.code,{children:".scss"})," files."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",metastring:"{14-32}",children:'// ignore other code ...\n\n// Implement Plugin Trait\nimpl Plugin for FarmPluginSass {\n  fn name(&self) -> &str {\n    "FarmPluginSass"\n  }\n\n  // this plugin should be executed before internal plugins\n  fn priority(&self) -> i32 {\n    101\n  }\n\n  fn load(\n    &self,\n    param: &farmfe_core::plugin::PluginLoadHookParam,\n    _context: &std::sync::Arc<farmfe_core::context::CompilationContext>,\n    _hook_context: &farmfe_core::plugin::PluginHookContext,\n  ) -> farmfe_core::error::Result<Option<farmfe_core::plugin::PluginLoadHookResult>> {\n    if param.query.is_empty() && self.regex.is_match(param.resolved_path) {\n      let content = fs::read_file_utf8(param.resolved_path);\n\n      if let Ok(content) = content {\n        return Ok(Some(farmfe_core::plugin::PluginLoadHookResult {\n          content,\n          module_type: ModuleType::Custom(String::from("sass")),\n        }));\n      }\n    }\n\n    Ok(None)\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"load"})," hook, we only read the file that ends with ",(0,s.jsx)(n.code,{children:".scss"})," or ",(0,s.jsx)(n.code,{children:".sass"}),", return the file content and maked its module_type as ",(0,s.jsx)(n.code,{children:'ModuleType::Custom(String::from("sass"))'}),"."]}),"\n",(0,s.jsxs)(n.h3,{id:"transform-sass-file",children:["Transform ",(0,s.jsx)(n.code,{children:"sass"})," File"]}),"\n",(0,s.jsxs)(n.p,{children:["After we load the ",(0,s.jsx)(n.code,{children:".scss"})," file, we need to transform it to ",(0,s.jsx)(n.code,{children:"css"})," in ",(0,s.jsx)(n.code,{children:"transform"})," hook, then Farm will treat it as css in following process."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// ignore other code ...\nfn transform(\n  &self,\n  param: &farmfe_core::plugin::PluginTransformHookParam,\n  context: &std::sync::Arc<farmfe_core::context::CompilationContext>,\n) -> farmfe_core::error::Result<Option<farmfe_core::plugin::PluginTransformHookResult>> {\n  // module type guard is neccessary\n  if param.module_type == ModuleType::Custom(String::from("sass")) {\n    // ... ignore other code\n\n    // parse options\n    const options = parse_options(&self.options, param.module_id);\n    // compile sass to css\n    let compile_result = compileSass(&param.content, options);\n\n    return Ok(Some(farmfe_core::plugin::PluginTransformHookResult {\n      content: compile_result.css,\n      source_map: compile_result.source_map,\n      // tell farm compiler that we have transformed this module to css\n      module_type: Some(farmfe_core::module::ModuleType::Css),\n      ignore_previous_source_map: false,\n    }));\n  }\n\n  Ok(None)\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["This example only covers how to implement a transformer plugin. For more abilities that Farm support, refer to ",(0,s.jsx)(n.a,{href:"/docs/api/rust-plugin-api",children:"Plugin Hooks"}),"."]})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},2438:(e,n,r)=>{r.d(n,{A:()=>o});r(758);var s=r(3526);const i={tabItem:"tabItem_MpMb"};var l=r(6070);function o(e){let{children:n,hidden:r,className:o}=e;return(0,l.jsx)("div",{role:"tabpanel",className:(0,s.A)(i.tabItem,o),hidden:r,children:n})}},6116:(e,n,r)=>{r.d(n,{A:()=>w});var s=r(758),i=r(3526),l=r(7356),o=r(5557),t=r(2492),a=r(3641),c=r(8902),u=r(408);function d(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:r}=e;return(0,s.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:r,attributes:s,default:i}}=e;return{value:n,label:r,attributes:s,default:i}}))}(r);return function(e){const n=(0,c.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,r])}function h(e){let{value:n,tabValues:r}=e;return r.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:r}=e;const i=(0,o.W6)(),l=function(e){let{queryString:n=!1,groupId:r}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:n,groupId:r});return[(0,a.aZ)(l),(0,s.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(i.location.search);n.set(l,e),i.replace({...i.location,search:n.toString()})}),[l,i])]}function g(e){const{defaultValue:n,queryString:r=!1,groupId:i}=e,l=p(e),[o,a]=(0,s.useState)((()=>function(e){let{defaultValue:n,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const s=r.find((e=>e.default))??r[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:l}))),[c,d]=m({queryString:r,groupId:i}),[g,f]=function(e){let{groupId:n}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(n),[i,l]=(0,u.Dv)(r);return[i,(0,s.useCallback)((e=>{r&&l.set(e)}),[r,l])]}({groupId:i}),x=(()=>{const e=c??g;return h({value:e,tabValues:l})?e:null})();(0,t.A)((()=>{x&&a(x)}),[x]);return{selectedValue:o,selectValue:(0,s.useCallback)((e=>{if(!h({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);a(e),d(e),f(e)}),[d,f,l]),tabValues:l}}var f=r(6328);const x={tabList:"tabList_cuZ3",tabItem:"tabItem_S_XB"};var j=r(6070);function y(e){let{className:n,block:r,selectedValue:s,selectValue:o,tabValues:t}=e;const a=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.a_)(),u=e=>{const n=e.currentTarget,r=a.indexOf(n),i=t[r].value;i!==s&&(c(n),o(i))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const r=a.indexOf(e.currentTarget)+1;n=a[r]??a[0];break}case"ArrowLeft":{const r=a.indexOf(e.currentTarget)-1;n=a[r]??a[a.length-1];break}}n?.focus()};return(0,j.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":r},n),children:t.map((e=>{let{value:n,label:r,attributes:l}=e;return(0,j.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>a.push(e),onKeyDown:d,onClick:u,...l,className:(0,i.A)("tabs__item",x.tabItem,l?.className,{"tabs__item--active":s===n}),children:r??n},n)}))})}function b(e){let{lazy:n,children:r,selectedValue:i}=e;const l=(Array.isArray(r)?r:[r]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===i));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,j.jsx)("div",{className:"margin-top--md",children:l.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==i})))})}function v(e){const n=g(e);return(0,j.jsxs)("div",{className:(0,i.A)("tabs-container",x.tabList),children:[(0,j.jsx)(y,{...n,...e}),(0,j.jsx)(b,{...n,...e})]})}function w(e){const n=(0,f.A)();return(0,j.jsx)(v,{...e,children:d(e.children)},String(n))}}}]);